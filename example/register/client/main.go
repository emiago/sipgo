package main

import (
	"context"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"strings"

	"github.com/emiago/sipgo"
	"github.com/emiago/sipgo/sip"

	"github.com/icholy/digest"
)

func main() {
	inter := flag.String("h", "127.0.0.1", "My interface ip or hostname")
	dst := flag.String("srv", "127.0.0.1:5060", "Destination")
	tran := flag.String("t", "udp", "Transport")
	user := flag.String("ua", "alice", "SIP Username")
	username := flag.String("u", "alice", "SIP Username")
	password := flag.String("p", "alice", "Password")
	flag.Parse()

	// Make SIP Debugging available
	sip.SIPDebug = os.Getenv("SIP_DEBUG") != ""

	var lvl slog.Level
	if err := lvl.UnmarshalText([]byte(os.Getenv("LOG_LEVEL"))); err != nil {
		lvl = slog.LevelInfo
	}
	slog.SetDefault(slog.New(slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{Level: lvl})))

	// Setup UAC
	ua, err := sipgo.NewUA(
		sipgo.WithUserAgent(*user),
	)
	if err != nil {
		slog.Error("Fail to setup user agent", "error", err)
		os.Exit(1)
	}

	client, err := sipgo.NewClient(ua, sipgo.WithClientHostname(*inter))
	if err != nil {
		slog.Error("Fail to setup client handle", "error", err)
		os.Exit(1)
	}
	defer client.Close()

	// Create basic REGISTER request structure
	recipient := sip.Uri{}
	sip.ParseUri(fmt.Sprintf("sip:%s@%s", *user, *dst), &recipient)
	req := sip.NewRequest(sip.REGISTER, recipient)
	req.AppendHeader(
		sip.NewHeader("Contact", fmt.Sprintf("<sip:%s@%s>", *username, *inter)),
	)
	req.SetTransport(strings.ToUpper(*tran))

	// Send request and parse response
	// req.SetDestination(*dst)
	slog.Info(req.StartLine())
	ctx := context.Background()
	tx, err := client.TransactionRequest(ctx, req)
	if err != nil {
		slog.Error("Fail to create transaction", "error", err)
		os.Exit(1)
	}
	defer tx.Terminate()

	res, err := getResponse(tx)
	if err != nil {
		slog.Error("Fail to get response", "error", err)
		os.Exit(1)
	}

	slog.Info("Received status", "status", int(res.StatusCode))
	if res.StatusCode == 401 {
		// Get WwW-Authenticate
		wwwAuth := res.GetHeader("WWW-Authenticate")
		chal, err := digest.ParseChallenge(wwwAuth.Value())
		if err != nil {
			slog.Error("Fail to parse challenge", "wwwauth", wwwAuth.Value(), "error", err)
			os.Exit(1)
		}

		// Reply with digest
		cred, _ := digest.Digest(chal, digest.Options{
			Method:   req.Method.String(),
			URI:      recipient.Host,
			Username: *username,
			Password: *password,
		})

		newReq := req.Clone()
		newReq.RemoveHeader("Via") // Must be regenerated by tranport layer
		newReq.AppendHeader(sip.NewHeader("Authorization", cred.String()))

		ctx := context.Background()
		tx, err := client.TransactionRequest(ctx, newReq, sipgo.ClientRequestAddVia)
		if err != nil {
			slog.Error("Fail to create transaction", "error", err)
			os.Exit(1)
		}
		defer tx.Terminate()

		res, err = getResponse(tx)
		if err != nil {
			slog.Error("Fail to get response", "error", err)
			os.Exit(1)
		}
	}

	if res.StatusCode != 200 {
		slog.Error("Fail to register")
		os.Exit(1)
	}

	slog.Info("Client registered")
}

func getResponse(tx sip.ClientTransaction) (*sip.Response, error) {
	select {
	case <-tx.Done():
		return nil, fmt.Errorf("transaction died")
	case res := <-tx.Responses():
		return res, nil
	}
}
